// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: `${string}://${string}` | (string & {});
};

export type ItemType = 'file' | 'folder';

export type SyncStatus = 'idle' | 'running' | 'done' | 'error' | 'cancelled' | 'interrupted';

export type SyncMode = 'auto' | 'full' | 'incremental';

export type ErrorCode = 'UNAUTHORIZED' | 'BAD_REQUEST' | 'NOT_FOUND' | 'CONFLICT' | 'RATE_LIMITED' | 'INTERNAL_ERROR';

export type IndexDocument = {
    doc_id: string;
    source_id: number;
    type: ItemType;
    name: string;
    path_text: string;
    parent_id: number;
    /**
     * Unix timestamp.
     */
    modified_at: number;
    /**
     * Unix timestamp.
     */
    created_at: number;
    size: number;
    sha1: string;
    in_trash: boolean;
    is_deleted: boolean;
    highlighted_name?: string;
};

export type QueryResult = {
    items: Array<IndexDocument>;
    total: number;
};

export type CrawlStats = {
    foldersVisited: number;
    filesIndexed: number;
    filesDiscovered: number;
    skippedFiles: number;
    pagesFetched: number;
    failedRequests: number;
    /**
     * Unix timestamp.
     */
    startedAt: number;
    /**
     * Unix timestamp.
     */
    endedAt: number;
};

export type RootSyncProgress = {
    rootFolderId: number;
    status: string;
    estimatedTotalDocs?: number | null;
    stats: CrawlStats;
    /**
     * Unix timestamp.
     */
    updatedAt: number;
};

export type IncrementalSyncStats = {
    changesFetched: number;
    upserted: number;
    deleted: number;
    skippedUpserts: number;
    skippedDeletes: number;
    cursorBefore: number;
    cursorAfter: number;
};

export type SyncVerification = {
    meiliDocCount: number;
    crawledDocCount: number;
    discoveredDocCount: number;
    skippedCount: number;
    verified: boolean;
    warnings?: Array<string>;
};

export type SyncProgressState = {
    status: SyncStatus;
    mode?: SyncMode;
    /**
     * Unix timestamp.
     */
    startedAt: number;
    /**
     * Unix timestamp.
     */
    updatedAt: number;
    roots: Array<number>;
    /**
     * Map of root folder ID to name.
     */
    rootNames?: {
        [key: string]: string;
    };
    completedRoots: Array<number>;
    activeRoot?: number | null;
    aggregateStats: CrawlStats;
    /**
     * Map of root folder ID (as string key) to its progress.
     */
    rootProgress: {
        [key: string]: RootSyncProgress;
    };
    incrementalStats?: IncrementalSyncStats | null;
    lastError?: string;
    verification?: SyncVerification | null;
};

export type SyncStartRequest = {
    mode?: SyncMode;
    root_folder_ids?: Array<number>;
    include_departments?: boolean | null;
    department_ids?: Array<number>;
    resume_progress?: boolean | null;
    root_workers?: number;
    progress_every?: number;
    checkpoint_template?: string;
    window_overlap_ms?: number;
    incremental_query?: string;
};

export type TokenRequest = {
    /**
     * Existing bearer token (if available).
     */
    token?: string;
    client_id?: string;
    client_secret?: string;
    sub_id?: number;
    sub_type?: string;
    oauth_host?: string;
};

export type RemoteSearchItem = {
    id: number;
    name: string;
    type: string;
};

export type RemoteSearchResponse = {
    files: Array<RemoteSearchItem>;
    folders: Array<RemoteSearchItem>;
    total_count: number;
    page_id: number;
    page_capacity: number;
    page_count: number;
};

export type ErrorResponse = {
    code: ErrorCode;
    message: string;
    request_id?: string;
};

export type HealthResponse = {
    status: string;
    running_sync: boolean;
};

export type ReadyResponse = {
    status: 'ready' | 'not_ready';
    /**
     * Present only when status is not_ready.
     */
    meili?: string;
};

export type DownloadUrlResponse = {
    file_id: number;
    download_url: string;
};

export type MessageResponse = {
    message: string;
};

/**
 * Search query string (alias `q` also accepted).
 */
export type QueryParam = string;

/**
 * Page number (1-based).
 */
export type PageParam = number;

/**
 * Number of results per page.
 */
export type PageSizeParam = number;

/**
 * Numeric file ID.
 */
export type FileIdParam = number;

/**
 * Download URL validity period in seconds.
 */
export type ValidPeriodParam = number;

export type HealthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/healthz';
};

export type HealthResponses = {
    /**
     * Service is alive.
     */
    200: HealthResponse;
};

export type HealthResponse2 = HealthResponses[keyof HealthResponses];

export type ReadyzData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/readyz';
};

export type ReadyzErrors = {
    /**
     * Meilisearch is unreachable.
     */
    503: ReadyResponse;
};

export type ReadyzError = ReadyzErrors[keyof ReadyzErrors];

export type ReadyzResponses = {
    /**
     * Service is ready.
     */
    200: ReadyResponse;
};

export type ReadyzResponse = ReadyzResponses[keyof ReadyzResponses];

export type AppSearchData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Search query string (alias `q` also accepted).
         */
        query: string;
        page?: number;
        page_size?: number;
    };
    url: '/api/v1/app/search';
};

export type AppSearchErrors = {
    /**
     * Missing or invalid query parameter.
     */
    400: ErrorResponse;
    /**
     * Search service unavailable.
     */
    500: ErrorResponse;
};

export type AppSearchError = AppSearchErrors[keyof AppSearchErrors];

export type AppSearchResponses = {
    /**
     * Search results.
     */
    200: QueryResult;
};

export type AppSearchResponse = AppSearchResponses[keyof AppSearchResponses];

export type AppDownloadUrlData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Numeric file ID.
         */
        file_id: number;
        /**
         * Download URL validity period in seconds.
         */
        valid_period?: number;
    };
    url: '/api/v1/app/download-url';
};

export type AppDownloadUrlErrors = {
    /**
     * Missing or invalid file_id.
     */
    400: ErrorResponse;
    /**
     * Upstream download URL generation failed.
     */
    502: ErrorResponse;
    /**
     * Download service unavailable (credential issue).
     */
    503: ErrorResponse;
};

export type AppDownloadUrlError = AppDownloadUrlErrors[keyof AppDownloadUrlErrors];

export type AppDownloadUrlResponses = {
    /**
     * Download URL generated.
     */
    200: DownloadUrlResponse;
};

export type AppDownloadUrlResponse = AppDownloadUrlResponses[keyof AppDownloadUrlResponses];

export type CreateTokenData = {
    body: TokenRequest;
    path?: never;
    query?: never;
    url: '/api/v1/token';
};

export type CreateTokenErrors = {
    /**
     * Invalid credentials or missing parameters.
     */
    400: ErrorResponse;
};

export type CreateTokenError = CreateTokenErrors[keyof CreateTokenErrors];

export type CreateTokenResponses = {
    /**
     * Token string.
     */
    200: string;
};

export type CreateTokenResponse = CreateTokenResponses[keyof CreateTokenResponses];

export type RemoteSearchData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Search query string (alias `q` also accepted).
         */
        query: string;
        /**
         * Item type filter.
         */
        type?: string;
        page_id?: number;
        query_filter?: string;
        search_in_folder?: number;
        updated_time_range?: string;
    };
    url: '/api/v1/search/remote';
};

export type RemoteSearchErrors = {
    /**
     * Missing query or invalid parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized.
     */
    401: ErrorResponse;
};

export type RemoteSearchError = RemoteSearchErrors[keyof RemoteSearchErrors];

export type RemoteSearchResponses = {
    /**
     * Upstream search results (proxied).
     */
    200: RemoteSearchResponse;
};

export type RemoteSearchResponse2 = RemoteSearchResponses[keyof RemoteSearchResponses];

export type LocalSearchData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Search query string (alias `q` also accepted).
         */
        query: string;
        /**
         * Page number (1-based).
         */
        page?: number;
        /**
         * Number of results per page.
         */
        page_size?: number;
        /**
         * Item type filter.
         */
        type?: string;
        parent_id?: number;
        /**
         * Unix timestamp lower bound.
         */
        updated_after?: number;
        /**
         * Unix timestamp upper bound.
         */
        updated_before?: number;
        /**
         * Include soft-deleted documents.
         */
        include_deleted?: boolean;
    };
    url: '/api/v1/search/local';
};

export type LocalSearchErrors = {
    /**
     * Missing query or invalid parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized.
     */
    401: ErrorResponse;
    /**
     * Search service unavailable.
     */
    500: ErrorResponse;
};

export type LocalSearchError = LocalSearchErrors[keyof LocalSearchErrors];

export type LocalSearchResponses = {
    /**
     * Local search results.
     */
    200: QueryResult;
};

export type LocalSearchResponse = LocalSearchResponses[keyof LocalSearchResponses];

export type DownloadUrlData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Numeric file ID.
         */
        file_id: number;
        /**
         * Download URL validity period in seconds.
         */
        valid_period?: number;
    };
    url: '/api/v1/download-url';
};

export type DownloadUrlErrors = {
    /**
     * Missing or invalid file_id.
     */
    400: ErrorResponse;
    /**
     * Unauthorized.
     */
    401: ErrorResponse;
};

export type DownloadUrlError = DownloadUrlErrors[keyof DownloadUrlErrors];

export type DownloadUrlResponses = {
    /**
     * Download URL generated.
     */
    200: DownloadUrlResponse;
};

export type DownloadUrlResponse2 = DownloadUrlResponses[keyof DownloadUrlResponses];

export type CancelSyncData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/admin/sync';
};

export type CancelSyncErrors = {
    /**
     * Unauthorized.
     */
    401: ErrorResponse;
    /**
     * No running sync to cancel.
     */
    409: ErrorResponse;
    /**
     * Rate limited.
     */
    429: ErrorResponse;
};

export type CancelSyncError = CancelSyncErrors[keyof CancelSyncErrors];

export type CancelSyncResponses = {
    /**
     * Cancel signal sent.
     */
    200: MessageResponse;
};

export type CancelSyncResponse = CancelSyncResponses[keyof CancelSyncResponses];

export type GetSyncProgressData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/admin/sync';
};

export type GetSyncProgressErrors = {
    /**
     * Unauthorized.
     */
    401: ErrorResponse;
    /**
     * No sync progress found.
     */
    404: ErrorResponse;
    /**
     * Rate limited.
     */
    429: ErrorResponse;
    /**
     * Failed to read sync progress.
     */
    500: ErrorResponse;
};

export type GetSyncProgressError = GetSyncProgressErrors[keyof GetSyncProgressErrors];

export type GetSyncProgressResponses = {
    /**
     * Current sync progress state.
     */
    200: SyncProgressState;
};

export type GetSyncProgressResponse = GetSyncProgressResponses[keyof GetSyncProgressResponses];

export type StartSyncData = {
    body: SyncStartRequest;
    path?: never;
    query?: never;
    url: '/api/v1/admin/sync';
};

export type StartSyncErrors = {
    /**
     * Invalid request body or missing credentials.
     */
    400: ErrorResponse;
    /**
     * Unauthorized.
     */
    401: ErrorResponse;
    /**
     * A sync job is already running.
     */
    409: ErrorResponse;
    /**
     * Rate limited.
     */
    429: ErrorResponse;
};

export type StartSyncError = StartSyncErrors[keyof StartSyncErrors];

export type StartSyncResponses = {
    /**
     * Sync job accepted.
     */
    202: MessageResponse;
};

export type StartSyncResponse = StartSyncResponses[keyof StartSyncResponses];
